# Product Context
This file defines the project scope, core knowledge, component architecture, technical standards, and key dependencies for the Chat Relay system.
## Project Overview and Goals
**Chat Relay** is a system designed to enable Cline/RooCode (or other AI development applications) to communicate with various web-based AI chat interfaces (such as Gemini, AI Studio, ChatGPT, and Claude) via an OpenAI-compatible API.
**Primary Goals**:
- Provide an OpenAI-compatible API endpoint for seamless integration with tools like Cline/RooCode.
- Relay messages to and from web-based chat UIs that may not have public APIs or offer different capabilities through their web interfaces.
- Enable interaction with multiple AI chat providers through a single, consistent API.
- Offer a modular architecture to easily support new chat providers in the future.
- Ensure robust handling of concurrent requests to prevent overloading browser extensions and maintain response integrity.

## Component Architecture
The system comprises three main components:
1.  **API Relay Server** ([`api-relay-server/`](api-relay-server/)):
    *   **Purpose**: Implements an OpenAI-compatible API endpoint (`/v1/chat/completions`) that client applications (e.g., Cline/RooCode) connect to. It manages WebSocket connections with the Browser Extension for real-time message relay. It now also includes a configurable message queuing/dropping system (`newRequestBehavior`) to manage request flow to the browser extension, ensuring only one message is actively processed by the extension at a time.
    *   **Key Files**: [`api-relay-server/src/server.ts`](api-relay-server/src/server.ts) (main server logic, including Express app, WebSocket server, queuing system, and admin UI).
2.  **Browser Extension** ([`extension/`](extension/)):
    *   **Purpose**: Runs in the user's browser (Chrome). It connects to the API Relay Server via WebSocket. It injects user messages into the target chat interface's DOM, simulates sending, and captures the AI's response from the UI.
    *   **Key Files**:
        *   [`extension/manifest.json`](extension/manifest.json): Defines extension properties, permissions, and scripts.
        *   [`extension/background.js`](extension/background.js): Service worker managing WebSocket connection and core relay logic.
        *   [`extension/content.js`](extension/content.js): Injected into chat interface pages to interact with the DOM.
        *   Provider-specific scripts (e.g., [`extension/providers/chatgpt.js`](extension/providers/chatgpt.js), [`extension/providers/aistudio.js`](extension/providers/aistudio.js), [`extension/providers/gemini.js`](extension/providers/gemini.js), [`extension/providers/claude.js`](extension/providers/claude.js)): Handle interactions for each supported chat UI.
        *   [`extension/providers/provider-utils.js`](extension/providers/provider-utils.js): Common utility functions for providers.
3.  **MCP Server** ([`mcp-server/`](mcp-server/)):
    *   **Purpose**: An optional Model Context Protocol server that can provide additional developer utilities, such as tools for simulating messages, testing extension interactions, or viewing communication traffic.
    *   **Key Files**: [`mcp-server/src/index.ts`](mcp-server/src/index.ts) (main server logic).

**Data Flow**:
1.  Cline/RooCode sends an HTTP POST request (OpenAI format) to the API Relay Server (`/v1/chat/completions`).
2.  The API Relay Server checks if a browser extension is currently processing a message (`activeExtensionProcessingId`).
    *   If the extension is busy:
        *   If `newRequestBehavior` is 'drop', the server responds with a 429 error.
        *   If `newRequestBehavior` is 'queue', the request (including the HTTP `res` object) is added to an in-memory `requestQueue`, and the HTTP response is deferred.
    *   If the extension is free, the server proceeds to step 3 directly with the current request.
3.  The API Relay Server (via `processRequest` function) sends the message content to the connected Browser Extension via WebSocket.
4.  The Browser Extension (using its content scripts and providers) injects the message into the active chat interface (e.g., Gemini) and simulates sending.
5.  The Extension captures the response generated by the chat interface from the UI.
6.  The Extension sends the captured response back to the API Relay Server via WebSocket.
7.  The API Relay Server (within `processRequest`) receives the response, formats it into an OpenAI-compatible JSON structure, and returns it to Cline/RooCode (using the original or stored `res` object).
8.  `finishProcessingRequest` is called, clearing the `activeExtensionProcessingId`. If requests are queued and `newRequestBehavior` is 'queue', the next request is dequeued and processed starting from step 3.

## Technical Standards
-   **API Relay Server & MCP Server**:
    *   Language: TypeScript. Indicated by [`api-relay-server/tsconfig.json`](api-relay-server/tsconfig.json), [`mcp-server/tsconfig.json`](mcp-server/tsconfig.json) and `.ts` files.
    *   Web Server Framework (API Relay): Express.js (from dependencies).
    *   WebSocket Communication: `ws` library.
    *   MCP Framework (MCP Server): `mcp-framework` library.
-   **Browser Extension**:
    *   Chrome Extension Manifest V3.
    *   Core Logic: Vanilla JavaScript.
    *   Communication: Native Browser WebSocket API to connect to the API Relay Server.
    *   DOM Manipulation for UI interaction.
-   **General**:
    *   Adherence to OpenAI API structure for `/v1/chat/completions` endpoint.
    *   Use of `npm` for package management.
    *   Configuration for API Relay Server via `server-config.json` and Admin UI.

## Key Dependencies
-   **API Relay Server** ([`api-relay-server/package.json`](api-relay-server/package.json)):
    *   `express`: Web framework.
    *   `ws`: WebSocket library.
    *   `cors`: Cross-Origin Resource Sharing middleware.
    *   `body-parser`: Request body parsing middleware.
    *   `typescript`, `nodemon` (dev).
-   **MCP Server** ([`mcp-server/package.json`](mcp-server/package.json)):
    *   `mcp-framework`: Core framework for MCP server development.
    *   `ws`: WebSocket library.
    *   `node-fetch`: For making HTTP requests.
    *   `zod`: Schema validation.
    *   `typescript` (dev).
-   **Browser Extension** ([`extension/manifest.json`](extension/manifest.json)):
    *   Relies on native browser APIs (DOM, WebSocket, Storage, Alarms, Scripting, Debugger, Tabs).
    *   No explicit third-party JavaScript libraries listed in the manifest; likely self-contained or using utility scripts like [`extension/providers/provider-utils.js`](extension/providers/provider-utils.js).

This document should be updated if the project's scope, architecture, or core technologies change significantly.